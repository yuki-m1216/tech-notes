# セキュアな開発と脆弱性管理

このセクションでは、開発段階からセキュリティを組み込み、運用時に継続的に脆弱性へ対応する考え方について学びます。

## このページで学ぶこと

- Shift Left（シフトレフト）の考え方と利点
- セキュアコーディングの基本原則
- セキュリティテストの自動化
- シークレット管理のベストプラクティス
- 脆弱性の優先順位付けとパッチ適用戦略
- 環境特性に応じたセキュリティ対策の選択
- AWS環境での実装パターン

---

## Shift Left の考え方

### 開発初期からセキュリティを考える

「Shift Left」とは、セキュリティ対策を開発プロセスの早い段階（左側）に移動させるアプローチです。

```
従来のアプローチ:
要件定義 → 設計 → 実装 → テスト → リリース → [セキュリティ]
                                              ↑ ここで発見

Shift Left:
要件定義 → 設計 → 実装 → テスト → リリース
    ↑        ↑       ↑       ↑
  セキュリティを各段階で組み込む
```

### なぜ早期に対処すべきか

脆弱性の修正コストは、発見が遅れるほど増大します：

| 発見フェーズ | 相対コスト | 理由 |
|------------|----------|------|
| 設計段階 | 1x | 設計変更のみ |
| 実装段階 | 5x | コード修正 + 再テスト |
| テスト段階 | 10x | 広範囲の修正 + 再テスト |
| リリース後 | 30x以上 | 緊急対応 + 顧客影響 + 信頼低下 |

!!! tip "コスト増大の参考"
    修正コストの増大については、[NIST SP 800-64](https://csrc.nist.gov/pubs/sp/800/64/r2/final) や IBM Systems Sciences Institute の研究で言及されています。具体的な倍率は環境によって異なりますが、後工程ほどコストが増大する傾向は広く認識されています。

### DevSecOps

DevOps に Security を組み込んだ考え方です：

- **継続的なセキュリティ**: CI/CDパイプラインにセキュリティチェックを統合
- **自動化**: 手動レビューに頼らず、ツールで検出
- **共有責任**: セキュリティチームだけでなく、開発チーム全体が責任を持つ

---

## セキュアコーディング

### OWASP Top 10

[OWASP Top 10](https://owasp.org/www-project-top-ten/) は、Webアプリケーションで最も重大なセキュリティリスクをまとめたものです。

**2021年版の主要項目:**

| 順位 | リスク | 概要 |
|-----|-------|------|
| A01 | アクセス制御の不備 | 認可チェックの欠如 |
| A02 | 暗号化の失敗 | 機密データの不適切な保護 |
| A03 | インジェクション | SQL、コマンド、XSSなど |
| A04 | 安全でない設計 | 設計段階でのセキュリティ欠如 |
| A05 | セキュリティ設定ミス | デフォルト設定、不要な機能 |

!!! note "OWASP Top 10 の位置づけ"
    OWASP Top 10 は網羅的なチェックリストではなく、「最低限対策すべきリスク」の認識を促すものです。これだけで十分とは考えないでください。

### 入力検証の原則

すべての外部入力は信頼できないものとして扱います：

**検証のポイント:**

- **型**: 期待するデータ型か
- **長さ**: 許容範囲内か
- **形式**: 期待するパターンに合致するか
- **範囲**: 有効な値の範囲内か

```
信頼境界の考え方:

┌─────────────────────────────────────┐
│  信頼できない領域                    │
│  ・ユーザー入力                      │
│  ・外部API                          │
│  ・ファイルアップロード              │
└─────────────────────────────────────┘
              │
              ▼ 入力検証
┌─────────────────────────────────────┐
│  信頼できる領域                      │
│  ・アプリケーション内部              │
└─────────────────────────────────────┘
              │
              ▼ 出力エスケープ
┌─────────────────────────────────────┐
│  出力先                             │
│  ・HTML、SQL、コマンドなど           │
└─────────────────────────────────────┘
```

### 出力エスケープ

データを出力する際は、出力先に応じた適切なエスケープが必要です：

| 出力先 | エスケープ方法 |
|-------|--------------|
| HTML | HTMLエンティティエスケープ |
| JavaScript | JavaScriptエスケープ |
| SQL | パラメータ化クエリ（プリペアドステートメント） |
| URL | URLエンコード |
| OS コマンド | 原則として外部入力を使わない |

!!! warning "コマンドインジェクション"
    OSコマンドに外部入力を渡すことは極めて危険です。どうしても必要な場合は、許可リストによる厳格な検証を行ってください。

---

## セキュリティテストの自動化

### SAST（静的アプリケーションセキュリティテスト）

ソースコードを解析して脆弱性を検出します。

**特徴:**

- コードを実行せずに解析
- 開発初期から適用可能
- 誤検知（False Positive）が多い傾向

**検出できる例:**

- SQLインジェクションの可能性
- ハードコードされた認証情報
- 安全でない関数の使用

### DAST（動的アプリケーションセキュリティテスト）

実行中のアプリケーションに対してテストを行います。

**特徴:**

- 実際の動作を検証
- 設定ミスや実行時の問題を検出
- テスト環境が必要

**検出できる例:**

- 実際に悪用可能なインジェクション
- 認証・認可の不備
- セキュリティヘッダーの欠如

### SAST と DAST の使い分け

| 観点 | SAST | DAST |
|-----|------|------|
| 実行タイミング | コード作成時 | アプリ実行時 |
| 検出対象 | コード上の問題 | 実行時の問題 |
| 誤検知 | 多い | 少ない |
| カバレッジ | コード全体 | テストした部分のみ |
| 修正の容易さ | 具体的な行を特定 | 原因特定に調査必要 |

**推奨: 両方を組み合わせて使用**

### CI/CDパイプラインへの統合

```
コード変更
    │
    ▼
┌─────────────┐
│   SAST      │ ← プルリクエスト時
│  (静的解析)  │
└─────────────┘
    │
    ▼
┌─────────────┐
│   ビルド     │
└─────────────┘
    │
    ▼
┌─────────────┐
│   DAST      │ ← ステージング環境
│  (動的解析)  │
└─────────────┘
    │
    ▼
┌─────────────┐
│  デプロイ    │
└─────────────┘
```

!!! tip "段階的な導入"
    最初から厳格なゲートを設けると開発が止まります。まずは「警告」として始め、徐々に「ブロック」に移行することを推奨します。

---

## シークレット管理

### なぜシークレットをコードに含めてはいけないか

コードにシークレットを含めることのリスク：

- **バージョン管理への混入**: Git履歴に永続的に残る
- **アクセス範囲の拡大**: コードを見られる人全員がシークレットにアクセス可能
- **ローテーションの困難**: 変更時に再デプロイが必要
- **漏洩時の被害拡大**: 1つの漏洩が複数環境に影響

### シークレットの種類と管理方法

| シークレット種類 | 管理方法 |
|----------------|---------|
| データベース認証情報 | シークレット管理サービス |
| APIキー | シークレット管理サービス |
| 暗号化キー | 専用の鍵管理サービス |
| 証明書 | 証明書管理サービス |
| 環境固有の設定 | 環境変数または設定管理 |

### シークレットローテーション

シークレットは定期的に更新（ローテーション）すべきです：

**ローテーションの利点:**

- 漏洩時の被害期間を限定
- 長期間使用による推測リスクの軽減
- コンプライアンス要件への対応

**自動ローテーションの考慮点:**

- アプリケーションが新しいシークレットを取得できるか
- ローテーション中のダウンタイム
- 依存するシステムへの影響

### 環境変数 vs 専用サービス

| 観点 | 環境変数 | 専用サービス |
|-----|---------|------------|
| 導入の容易さ | 簡単 | 設定が必要 |
| 監査ログ | なし | あり |
| アクセス制御 | 粗い | きめ細かい |
| ローテーション | 手動 | 自動化可能 |
| 暗号化 | 別途対応 | 標準で暗号化 |

!!! note "環境変数の限界"
    環境変数は手軽ですが、プロセス一覧やログに露出するリスクがあります。本番環境では専用のシークレット管理サービスの使用を推奨します。

---

## 脆弱性管理

### すべてに対応することは不可能

現実として：

- 新しい脆弱性は毎日公開される
- すべてのシステムを即座に更新することは困難
- パッチ適用にはテストとリリースのコストがかかる

**だからこそ、優先順位付けが重要です。**

### CVSS（Common Vulnerability Scoring System）

[CVSS](https://www.first.org/cvss/) は脆弱性の重大度を数値化する業界標準です：

| スコア | 重大度 |
|-------|-------|
| 9.0-10.0 | Critical |
| 7.0-8.9 | High |
| 4.0-6.9 | Medium |
| 0.1-3.9 | Low |

**CVSSの構成要素:**

- **Base Score**: 脆弱性固有の特性
- **Temporal Score**: 時間経過による変化（エクスプロイト公開など）
- **Environmental Score**: 環境固有の要因

### CVSSだけで判断してはいけない理由

CVSSスコアは重要な指標ですが、以下の点で限界があります：

| CVSSの限界 | 実際の考慮点 |
|-----------|------------|
| 環境を考慮しない | インターネット公開 vs 内部システム |
| 悪用状況を反映しない | 実際にエクスプロイト（攻撃コード）が出回っているか |
| ビジネス影響を含まない | そのシステムの重要度 |

**リスクベースの優先順位付け:**

```
優先度 = 脆弱性の深刻度 × 悪用可能性 × ビジネス影響

例:
・CVSS 9.0 + エクスプロイトなし + 内部システム → 中優先
・CVSS 7.0 + エクスプロイト公開 + 顧客向けシステム → 高優先
```

### CISA KEV（Known Exploited Vulnerabilities）

[CISA KEV Catalog](https://www.cisa.gov/known-exploited-vulnerabilities-catalog) は、実際に悪用が確認された脆弱性のリストです。

- 米国サイバーセキュリティ・インフラセキュリティ庁（CISA）が管理
- 実際の攻撃で使用されている脆弱性
- CVSSスコアが低くても、悪用実績があれば優先対応の指標に

---

## パッチ適用戦略

### パッチ適用のトレードオフ

| 早期適用 | 慎重な適用 |
|---------|----------|
| 脆弱性への露出期間が短い | 十分なテストが可能 |
| パッチ自体の不具合リスク | 攻撃を受けるリスク |
| テスト不足による障害 | 安定した運用 |

### 緊急度による分類

対応期限は組織やシステムの特性により異なりますが、以下は分類の一例です：

| 緊急度 | 条件 | 対応目安（例） |
|-------|------|--------------|
| 緊急 | 悪用実績あり + 外部公開システム | 即時〜24時間 |
| 高 | Critical/High + 外部公開 | 1週間以内 |
| 中 | Critical/High + 内部システム | 1ヶ月以内 |
| 低 | Medium以下 | 定期メンテナンス時 |

!!! note "対応期限の決定"
    実際の対応期限は、システムの重要度、チームのリソース、変更管理プロセスなどを考慮して組織ごとに定義してください。

!!! warning "ゼロデイ脆弱性"
    パッチ公開前に悪用が始まる「ゼロデイ」の場合は、一時的な緩和策（WAFルール、機能無効化など）を検討してください。

### テストとリリースのバランス

```
緊急度: 高
┌─────────────────────────────────────────┐
│ 最小限のテスト → 本番適用 → 詳細モニタリング │
└─────────────────────────────────────────┘

緊急度: 通常
┌─────────────────────────────────────────┐
│ 開発環境 → ステージング → 本番（段階的）    │
└─────────────────────────────────────────┘
```

---

## AWS環境での実装パターン

### シークレット管理サービスの選択

| サービス | 用途 | 特徴 |
|---------|------|------|
| Secrets Manager | データベース認証情報、APIキー | 自動ローテーション対応 |
| Systems Manager Parameter Store | 設定値、シークレット | 低コスト、階層構造 |
| KMS | 暗号化キーの管理 | 他サービスと統合 |

**使い分けの指針:**

- **自動ローテーションが必要** → Secrets Manager
- **コストを抑えたい、設定値も管理** → Parameter Store（SecureString）
- **暗号化キーの管理** → KMS

### Secrets Manager の活用

```
アプリケーション          Secrets Manager          RDS
     │                        │                    │
     │  1. シークレット取得    │                    │
     │ ─────────────────────► │                    │
     │                        │                    │
     │  2. 認証情報を返却      │                    │
     │ ◄───────────────────── │                    │
     │                        │                    │
     │  3. DBに接続            │                    │
     │ ──────────────────────────────────────────► │
     │                        │                    │
     │                        │  自動ローテーション  │
     │                        │ ◄─────────────────► │
```

### 脆弱性スキャンサービス

| サービス | 対象 | 特徴 |
|---------|------|------|
| Amazon Inspector | EC2、ECR、Lambda、コードスキャン | 継続的スキャン、SAST機能含む |
| ECR イメージスキャン | コンテナイメージ | プッシュ時の基本スキャン |
| GuardDuty Malware Protection | EC2、EBS | マルウェアスキャン（イベントトリガー） |

### 環境特性に応じたセキュリティ対策

有効なセキュリティ対策は、環境のライフサイクルと変更の扱いによって異なります。

| 環境特性 | コンテナ（ECS/EKS） | 従来型VM（EC2長期稼働） |
|---------|-------------------|----------------------|
| ライフサイクル | 短命（分〜時間単位） | 長期（月〜年単位） |
| 変更の扱い | イミュータブル（変更時は再デプロイ） | ミュータブル（稼働中に変更） |
| 有効な対策 | イメージスキャン + 実行時異常検知 | エージェント型セキュリティ |

**コンテナ環境:**

- デプロイ前のイメージスキャンで脆弱性を検出
- 実行中のファイル変更は異常とみなせるため、異常検知が有効
- [AWS ECS セキュリティベストプラクティス](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/security-tasks-containers.html)では、"You should consider the container image as your first line of defense against an attack."（コンテナイメージを攻撃に対する最初の防御線と考えるべき）と述べられています

**従来型VM環境（EC2長期稼働）:**

- 稼働中にパッチ適用やファイル変更が発生するため、継続的な監視が必要
- リアルタイムスキャン、IDS/IPS、整合性監視などのエージェント型対策が有効
- AWSサービスでは GuardDuty Malware Protection、Inspector、Network Firewall などを組み合わせて対応

### Inspector の活用

Amazon Inspector は継続的に脆弱性をスキャンします：

**対象リソース:**

- EC2インスタンス（SSM Agent経由）
- ECRコンテナイメージ
- Lambda関数

**検出結果の活用:**

```
Inspector → Security Hub → EventBridge → 通知/自動修復
                              │
                              ▼
                        ・SNS通知
                        ・Lambda（自動対応）
                        ・チケット作成
```

### CodePipeline でのセキュリティゲート

```
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   Source    │───►│    Build    │───►│   Deploy    │
│  (CodeCommit)│    │ (CodeBuild) │    │             │
└─────────────┘    └─────────────┘    └─────────────┘
                         │
                         ▼
                   ┌─────────────┐
                   │ セキュリティ │
                   │  チェック    │
                   │・SAST       │
                   │・依存関係   │
                   │・シークレット│
                   │  スキャン   │
                   └─────────────┘
```

**CodeBuild での実装例:**

- コード内のシークレットスキャン（git-secrets、truffleHog）
- 依存関係の脆弱性チェック（npm audit、Trivy）
- SASTツールの実行

### よくある失敗パターン

!!! failure "失敗例1: シークレットがGit履歴に残っている"
    ```
    ❌ 一度コミットしたシークレットを削除して再コミット
       → Git履歴には残り続ける

    ✅ シークレットが漏洩した場合:
       ・即座にシークレットをローテーション
       ・Git履歴の書き換えは困難なため、
         シークレット自体の無効化を優先
    ```

!!! failure "失敗例2: CVSSスコアだけで優先度を決定"
    ```
    ❌ CVSS 9.0以上は全て最優先で対応

    ✅ 以下を総合的に判断:
       ・実際にエクスプロイトが存在するか（CISA KEV等）
       ・対象システムの公開範囲
       ・ビジネスへの影響度
    ```

!!! failure "失敗例3: セキュリティスキャンの結果を無視"
    ```
    ❌ SASTの警告が多すぎて全て無視

    ✅ 段階的なアプローチ:
       ・まずは Critical/High のみ対応
       ・誤検知は抑制ルールで管理
       ・新規の警告はゼロにする方針
    ```

---

## まとめ

セキュアな開発と脆弱性管理の要点：

1. **Shift Left**: 開発の早い段階からセキュリティを組み込む
2. **セキュアコーディング**: 入力検証と出力エスケープを徹底
3. **自動化**: SAST/DASTをCI/CDパイプラインに統合
4. **シークレット管理**: コードに含めず、専用サービスで管理
5. **リスクベースの優先順位**: CVSSだけでなく、悪用状況とビジネス影響を考慮
6. **環境特性に応じた対策**: コンテナと従来型VMで有効な対策が異なる
7. **継続的な対応**: 脆弱性管理は一度で終わりではなく、継続的なプロセス

完璧なコードは存在しませんが、適切なプロセスと自動化により、脆弱性を早期に発見し、効率的に対処することができます。

[規制対応とデータ保護を学ぶ →](compliance.md){ .md-button }
